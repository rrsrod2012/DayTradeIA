generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "sqlite"
  url      = env("DATABASE_URL")
}

model Instrument {
  id                Int                @id @default(autoincrement())
  symbol            String             @unique
  name              String
  backtests         BacktestRun[]
  candles           Candle[]
  trades            Trade[]
  processingCursors ProcessingCursor[] // back-relation
}

model Candle {
  id           Int              @id @default(autoincrement())
  instrumentId Int
  timeframe    String
  time         DateTime
  open         Float
  high         Float
  low          Float
  close        Float
  volume       Float
  instrument   Instrument       @relation(fields: [instrumentId], references: [id])
  indicators   IndicatorValue[]
  patterns     Pattern[]
  signals      Signal[]

  @@unique([instrumentId, timeframe, time], name: "instrument_time_tf_unique")
}

model IndicatorValue {
  id       Int    @id @default(autoincrement())
  candleId Int
  key      String
  value    Float
  candle   Candle @relation(fields: [candleId], references: [id])
}

model Pattern {
  id       Int    @id @default(autoincrement())
  candleId Int
  type     String
  strength Float
  candle   Candle @relation(fields: [candleId], references: [id])
}

model Signal {
  id         Int    @id @default(autoincrement())
  candleId   Int
  signalType String
  side       String
  meta       Json?
  candle     Candle @relation(fields: [candleId], references: [id])

  // Back-relations para Trade
  entryOfTrades Trade[] @relation("EntrySignal")
  exitOfTrades  Trade[] @relation("ExitSignal")

  @@unique([candleId, signalType, side], name: "candle_signal_side_unique")
}

model Trade {
  id            Int          @id @default(autoincrement())
  instrumentId  Int
  timeframe     String
  entrySignalId Int          @unique // <<< campo único direto (estável no Client)
  exitSignalId  Int?
  qty           Int
  entryPrice    Float
  exitPrice     Float?
  pnlPoints     Float?
  pnlMoney      Float?
  backtestRunId Int?
  backtestRun   BacktestRun? @relation(fields: [backtestRunId], references: [id])

  exitSignal  Signal? @relation("ExitSignal", fields: [exitSignalId], references: [id])
  entrySignal Signal  @relation("EntrySignal", fields: [entrySignalId], references: [id])

  instrument Instrument @relation(fields: [instrumentId], references: [id])
}

model BacktestRun {
  id           Int        @id @default(autoincrement())
  instrumentId Int
  timeframe    String
  startedAt    DateTime   @default(now())
  finishedAt   DateTime?
  params       String
  totalPnL     Float?
  instrument   Instrument @relation(fields: [instrumentId], references: [id])
  trades       Trade[]
}

model TrainingRun {
  id         Int              @id @default(autoincrement())
  startedAt  DateTime         @default(now())
  finishedAt DateTime?
  params     String
  notes      String?
  metrics    TrainingMetric[]
}

model TrainingMetric {
  id        Int         @id @default(autoincrement())
  runId     Int
  t         Int
  loss      Float?
  accuracy  Float?
  ev        Float?
  createdAt DateTime    @default(now())
  run       TrainingRun @relation(fields: [runId], references: [id])
}

model BrokerTask {
  id        String   @id
  agentId   String
  side      String
  symbol    String?
  timeframe String?
  createdAt DateTime @default(now())
  status    String?
  payload   String?
}

model BrokerExecution {
  id        Int       @id @default(autoincrement())
  taskId    String?
  agentId   String
  side      String
  symbol    String?
  orderId   String?
  status    String?
  time      DateTime?
  price     Int?
  volume    Int?
  pnlPoints Int?
  raw       String?
  createdAt DateTime  @default(now())
}

// Cursor incremental por instrumento/timeframe
model ProcessingCursor {
  id                Int      @id @default(autoincrement())
  instrumentId      Int
  timeframe         String
  lastProcessedTime DateTime

  instrument Instrument @relation(fields: [instrumentId], references: [id])

  @@unique([instrumentId, timeframe], name: "cursor_instrument_tf_unique")
}
